//                      
//             
//                        ghv : Garrett Vance : 20170407 
//  
//                           file  gv_SCENE_3D.cpp      
//      Synthesized from MSVC template Visual C++ >> Windows >> Universal 
//                      DirectX 11 App (Universal Windows), Windows 10
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  

#include "pch.h"
#include "gv_SCENE_3D.h"
#include "..\Common\DirectXHelper.h"




using namespace VHG;
using namespace DirectX;
using namespace DirectX::SimpleMath;
using namespace Windows::Foundation;


using namespace Windows::Foundation::Diagnostics; 


static const DirectX::XMVECTORF32 START_POSITION = { 0.0f, 0.0f, -13.5f, 0.0f };

DirectX::SimpleMath::Vector3 gv_Calc_kminput_x_y_z_From_Pitch_Yaw(float p_pitch, float p_yaw);  // prototype;


Windows::Foundation::Diagnostics::LoggingChannel^ VHG::VHG_Scene3D1::e_ghv_loggingChannel = ref new LoggingChannel( "SampleProvider", nullptr); // null means use default options.


UINT const VHG::VHG_Scene3D1::e_verts_per_quad = 6;


//  undo  UINT const VHG::VHG_Scene3D1::tubeFacets = 4; 

UINT const VHG::VHG_Scene3D1::tubeFacets = 7; 



static const float MOVEMENT_GAIN = 0.07f;




int CWS_ALIGNMENT_RoundUpTo16(int p_some_value)
{
    //      This method is useful when defining constant buffers, as
    //      their size must be a multiple of 16 bytes.
    //              
    //          
    // https://msdn.microsoft.com/en-us/library/windows/desktop/bb509632%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
    //          
    //      0xF = 1111 binary;
    //
    //  So the least significant 4 bits of e.g. ~0x000F
    //  will be four zeros: 
    //      ~0x000F = 1111  1111  1111  1111  0000
    //  
    //  In particular, ~0xF = 0000 binary;
    //     

    return (p_some_value + 15) & ~0xF;
}
//  Closes CWS_ALIGNMENT_RoundUpTo16();








 


VHG_Scene3D1::VHG_Scene3D1(const std::shared_ptr<DX::DeviceResources>& deviceResources) :
    m_deviceResources(deviceResources),  
    m_loadingComplete(false),
    e_pitch(0), 
	e_yaw(0), 
	e_advert_modulus(21), 
    e_advert_count(0),
	m_degreesPerSecond(45),  

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    e_rasterizer_fill_mode_loft(D3D11_FILL_SOLID),  //  TODO:   separate the S2sphere from the INodes cubes fill_mode;
    e_option_Hopf_rotating(true), 
    e_option_S2sphere_rotating(true), 
    e_option_Hopf_x_axis_ortho(true), 
    e_ib_indices_card_MQuad(0), 
    e_conbuf_Loft_fiberColoringMode_data(2)   //   Semantics: 1 ==> color per fiber; 2 ==> color per torus;

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


{  
    e_keyboard = std::make_unique<DirectX::Keyboard>();
    e_keyboard->SetWindow(Windows::UI::Core::CoreWindow::GetForCurrentThread());

    e_mouse = std::make_unique<DirectX::Mouse>();
    e_mouse->SetWindow(Windows::UI::Core::CoreWindow::GetForCurrentThread());




    // The 2-parameter constructor creates a channel with Windows 10 semantics.

    //  moved  e_ghv_loggingChannel = ref new LoggingChannel( "SampleProvider", nullptr); // null means use default options.


    // The Id is generated by hashing the string "SampleProvider".
    // channel.Id == eff1e128-4903-5093-096a-bdc29b38456f



    e_HopfSystem = std::make_unique<VHG::VHG_HopfSystem>(deviceResources);  

    CreateDeviceDependentResources();
    CreateWindowSizeDependentResources();
}  
//  Closes class ctor;  





void VHG_Scene3D1::CreateWindowSizeDependentResources(void)
{ 
    // Initializes view parameters when the window size changes.
    
    Size outputSize = m_deviceResources->GetOutputSize(); 
    float aspectRatio = outputSize.Width / outputSize.Height;  
    float fovAngleY = 70.0f * XM_PI / 180.0f;

    XMMATRIX projectionMatrixLeftHand = XMMatrixPerspectiveFovLH(  //  CHIRALITY SINISTRAL;
        fovAngleY, aspectRatio, 0.01f, 650.0f );

    e_camera_position = START_POSITION.v;
    DirectX::SimpleMath::Vector3 tmp_kminput = gv_Calc_kminput_x_y_z_From_Pitch_Yaw(e_pitch, e_yaw);
    DirectX::SimpleMath::Vector3 camera_target = e_camera_position + tmp_kminput;
    DirectX::SimpleMath::Vector3 camera_up_vector = DirectX::SimpleMath::Vector3::Up;

    XMMATRIX viewMatrixLeftHanded = XMMatrixLookAtLH(e_camera_position, camera_target, camera_up_vector);

    XMMATRIX viewProjectionMatrix = viewMatrixLeftHanded * projectionMatrixLeftHand;

    XMStoreFloat4x4(
        &e_conbuf_ViewProjection_data.viewProjection, 
        XMMatrixTranspose(
            viewProjectionMatrix
        )
    );




    XMStoreFloat4x4(
        &e_conbuf_MQuad_ViewProjectionTransform_data.projection_transform,
        XMMatrixTranspose(
            projectionMatrixLeftHand
        )
    );

    XMStoreFloat4x4(
        &e_INodes_MVP_data.projection_transform,
        XMMatrixTranspose(
            projectionMatrixLeftHand
        )
    );


    GV_Camera_Init();
}  
//  Closes VHG_Scene3D1::CreateWindowSizeDependentResources();






void VHG_Scene3D1::UpdateDynamic_ColoringMode(void)
{
    //      KMI might have altered the fiberColoringMode, 
    //      so update the data for the e_conbuf_fiberColoringMode_buffer 
    //      dynamic constant buffer: 
    //      

    D3D11_MAPPED_SUBRESOURCE mappedResource;


    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDeviceContext()->Map( 
            e_conbuf_Loft_fiberColoringMode_buffer.Get(), 
            0, 
            D3D11_MAP_WRITE_DISCARD, 
            0, 
            &mappedResource
        )
    );


    *static_cast<int*>(mappedResource.pData) = e_conbuf_Loft_fiberColoringMode_data;


    m_deviceResources->GetD3DDeviceContext()->Unmap(
        e_conbuf_Loft_fiberColoringMode_buffer.Get(),
        0
    );
}
//  Closes VHG_Scene3D1::UpdateDynamic_ColoringMode(); 




void VHG_Scene3D1::gv_map_unmap_vertex_buffer(float p_StepSize)
{
    VHG_Scene3D1::e_ghv_loggingChannel->LogMessage("gv_map_unmap: begin;"); 


    ID3D11DeviceContext3   *dev_con = m_deviceResources->GetD3DDeviceContext();
    D3D11_MAPPED_SUBRESOURCE mapped_subresource;

    //  TODO: for each Trajectory in the vector of trajectories, 
    //  need to destruct all of its Fibers. 
    //  Need to delete all the old Trajectories before adding new ones...

    //  
    //  For each relevant buffer, call ID3D11DeviceContext::Map 
    //	to disable GPU access to the buffer, present the new data, 
    //  the call Unmap to re-enable GPU access to that buffer. 
    //  

    e_HopfSystem->e_trajectories->clear();

    std::vector<VHG_Instance>* tmpInstances = new std::vector<VHG_Instance>;

    this->e_HopfSystem->AddTrajectories(tmpInstances, p_StepSize); 

    e_ghv_loggingChannel->LogMessage("gv_map_unmap: AddTrajectories done;"); 


    e_HopfSystem->e_INodes_instance_card = (uint32_t)tmpInstances->size();

    ZeroMemory(&mapped_subresource, sizeof(D3D11_MAPPED_SUBRESOURCE));
    dev_con->Map(e_HopfSystem->e_INodes_instance_buffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_subresource);
    memcpy(
        mapped_subresource.pData,
        &(*tmpInstances)[0],
        sizeof(VHG_Instance) * tmpInstances->size()
    );
    dev_con->Unmap(e_HopfSystem->e_INodes_instance_buffer.Get(), 0);


    e_ghv_loggingChannel->LogMessage("gv_map_unmap: INodes instance buffer copy done;"); 



    this->e_HopfSystem->CreateLoft(); 

    e_ghv_loggingChannel->LogMessage("gv_map_unmap: CreateLoftDeprecated done;"); 




    ZeroMemory(&mapped_subresource, sizeof(D3D11_MAPPED_SUBRESOURCE));
    dev_con->Map(e_vertex_buffer_loft.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_subresource);
    memcpy(
        mapped_subresource.pData,
        &(*e_HopfSystem->e_master_lofts)[0],
        sizeof(VHG_Loft_Vertex) * e_HopfSystem->e_master_lofts->size()
    );
    dev_con->Unmap(e_vertex_buffer_loft.Get(), 0);


#ifdef GHV_OPTION_INDEX_BUFFER
    ZeroMemory(&mapped_subresource, sizeof(D3D11_MAPPED_SUBRESOURCE));
    dev_con->Map(e_index_buffer_loft.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_subresource);
    memcpy(
        mapped_subresource.pData,
        &(*e_HopfSystem->e_master_indices)[0],
        sizeof(DWORD) * e_HopfSystem->e_master_indices->size()
    );
    dev_con->Unmap(e_index_buffer_loft.Get(), 0);
#endif 


    e_ghv_loggingChannel->LogMessage("gv_map_unmap: VertexBuffer+IndexBuffer done;"); 

    e_ghv_loggingChannel->LogMessage("gv_map_unmap: end;"); 
}





void VHG_Scene3D1::Update3DScene(DX::StepTimer const& timer)
{
    // 
    //           Called once per frame, updates
    //           the model and view matrices.
    //


#ifdef GHV_OPTION_ANIMATE_EXVERSION
    static double earlierSeconds = timer.GetTotalSeconds(); 
    double laterSeconds = timer.GetTotalSeconds(); 
    double animationPeriod = 0.40;  //  0.80;
    if (laterSeconds - earlierSeconds > animationPeriod)
    {
        earlierSeconds = laterSeconds;
        gv_map_unmap_vertex_buffer();
    }
#endif



    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // 
    //                Free-Look Camera 
    // 
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    float            gv_elapsed_time = float(timer.GetElapsedSeconds());
    DirectX::SimpleMath::Vector3       kminput_move = this->gv_Handle_KMI(gv_elapsed_time);

    DirectX::SimpleMath::Vector3 risk_DefaultForward = XMVectorSet(0.0f, 0.0f, 1.0f, 0.f);
    DirectX::SimpleMath::Vector3 risk_DefaultRight = XMVectorSet(1.0f, 0.0f, 0.0f, 0.f);

    DirectX::SimpleMath::Vector3 risk_camForward = XMVectorSet(0.0f, 0.0f, 1.0f, 0.f);
    DirectX::SimpleMath::Vector3 risk_camRight = XMVectorSet(1.0f, 0.0f, 0.0f, 0.f);

    DirectX::SimpleMath::Matrix   risk_camRotationMatrix = XMMatrixRotationRollPitchYaw(e_pitch, e_yaw, 0);

    risk_camRight = XMVector3TransformCoord(risk_DefaultRight, risk_camRotationMatrix);
    risk_camForward = XMVector3TransformCoord(risk_DefaultForward, risk_camRotationMatrix); 

    DirectX::SimpleMath::Vector3 risk_camUp = XMVector3Cross(risk_camForward, risk_camRight);

    kminput_move *= MOVEMENT_GAIN;

    e_camera_position += kminput_move.x * risk_camRight; 
    e_camera_position += kminput_move.z * risk_camForward;

    kminput_move = DirectX::SimpleMath::Vector3::Zero;  //  redundant ;

    DirectX::SimpleMath::Vector3  risk_camTarget = XMVector3TransformCoord( risk_DefaultForward, risk_camRotationMatrix); 
    risk_camTarget = XMVector3Normalize(risk_camTarget); 
    risk_camTarget += e_camera_position;

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //    
    //       Update the View Transform(s): 
    //     
    //    
    //   Hazard: Don't update the view transform data 
    //   held in    &e_conbuf_MQuad_ViewProjectionTransform_data.view_transform,
    //   or else the MQuad pair of triangles will morph into a rhombus, 
    //   then a frustum, then a skewed plane, etc... You get the picture. 
    //   The MQuad is intended to always remain a flat orthogonal square 
    //   composed of two triangles. 
    //    
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   
    Size outputSize = m_deviceResources->GetOutputSize(); 
    float aspectRatio = outputSize.Width / outputSize.Height;  
    float fovAngleY = 70.0f * XM_PI / 180.0f;

    XMMATRIX projectionMatrixLeftHand = XMMatrixPerspectiveFovLH(  //  CHIRALITY SINISTRAL;
        fovAngleY, aspectRatio, 0.01f, 650.0f );

    XMMATRIX viewMatrixLeftHanded = XMMatrixLookAtLH(e_camera_position, risk_camTarget, risk_camUp);

    XMMATRIX viewProjectionMatrix = viewMatrixLeftHanded * projectionMatrixLeftHand;

    XMStoreFloat4(
        &e_conbuf_ViewProjection_data.cameraPosition,
        e_camera_position
    );

    float lightPosW = 1.f; 
    e_conbuf_ViewProjection_data.lightPosition = XMFLOAT4(5.1f, 5.2f, -0.5f, lightPosW);  


    XMStoreFloat4x4(
        &e_conbuf_ViewProjection_data.viewProjection, 
        XMMatrixTranspose(
            viewProjectionMatrix
        )
    );


    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //          
    //  Each mesh object in the scene has its own Model Transform 
    //  to move its mesh into one common World Space coordinate system: 
    //          
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	
	//=================================================================
	//				The lofted Hopf Fibers in R3: 
	//=================================================================
    XMMATRIX hopf_loft_rotation = do_Hopf_rotation(timer);
    XMMATRIX hopf_loft_scaling = XMMatrixScaling(4.f, 4.f, 4.f);
    XMMATRIX hopf_loft_translation = XMMatrixTranslation(0.f, 0.f, 6.f); // GOLD z = +2.f;

    XMMATRIX loft_modelToWorldMatrix = hopf_loft_rotation * hopf_loft_scaling * hopf_loft_translation;  //  Use RST;

    XMStoreFloat4x4(
        &e_conbuf_ModelNormal_data.modelToWorld, 
        XMMatrixTranspose( 
            loft_modelToWorldMatrix 
        )
    );

    XMMATRIX normalTransform = loft_modelToWorldMatrix;

    // Normals are not translated, so we remove the translation component here.

    normalTransform.r[3] = XMVectorSet(0.f, 0.f, 0.f, XMVectorGetW(normalTransform.r[3]));

    XMStoreFloat4x4(
        &e_conbuf_ModelNormal_data.normalToWorld,
        XMMatrixTranspose(
            normalTransform
        )
    );

    float colorFadeFactor = 0.7f; 
    e_conbuf_ModelNormal_data.colorFadeFactor = XMFLOAT4(colorFadeFactor, colorFadeFactor, colorFadeFactor, 1.f);










	//=================================================================
	//			 The MQuad (background for S2sphere): 
	//=================================================================
    float mquad_scale = 8.f;
    // undo : XMMATRIX model_transform_MQuad = XMMatrixTranslation(-0.5f, 0.f, 0.f)...etc...
    XMMATRIX model_transform_MQuad = XMMatrixScaling(mquad_scale, mquad_scale, 1.f);

    XMStoreFloat4x4(
        &e_conbuf_MQuad_ModelTransform_data.model_transform,
        XMMatrixTranspose(
            model_transform_MQuad
        )
    );

	//=================================================================
	//			 The S2sphere and its cloud of INodes: 
	//=================================================================
    XMMATRIX S2sphere_rotation = do_S2sphere_rotation(timer);
    float s = 3.8f;
    XMMATRIX S2sphere_scaling = XMMatrixScaling(s, s, s);
	XMMATRIX S2sphere_model_transform = S2sphere_rotation * S2sphere_scaling; 
    XMStoreFloat4x4(
        &e_conbuf_S2sphere_ModelTransform_data.model_transform, 
        XMMatrixTranspose( 
            S2sphere_model_transform 
        )
    );
    XMStoreFloat4x4(
        &e_INodes_MVP_data.model_transform, 
        XMMatrixTranspose( 
            S2sphere_model_transform 
        )
    );

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    //      Animators : INodes and Advert: 
    //
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    this->AdvertUpdate(); 

    this->S2sphere_INodes_Animator();
}  
//  Closes VHG_Scene3D1::Update3DScene();


 






void VHG_Scene3D1::AdvertUpdate()
{
    static uint16_t     delay_idx = 0;
    uint16_t const      delay_speed = 8;  // GOLD: 10; 

    (delay_idx + 1) > UINT16_MAX ? delay_idx = 0 : delay_idx++;

    if (delay_idx % delay_speed == 0)
    {
        e_advert_count = (1 + e_advert_count) % (1 + 2 * e_advert_modulus);
    }
}  








void VHG_Scene3D1::RenderMQuad(void)
{
    auto context = m_deviceResources->GetD3DDeviceContext();

    //  Update MVP data for the MQuad: 

    context->UpdateSubresource1(
        e_conbuf_MQuad_ViewProjectionTransform_buffer.Get(), 
        0, 
        NULL, 
        &e_conbuf_MQuad_ViewProjectionTransform_data, 
        0, 0, 0);

    context->UpdateSubresource1(
        e_conbuf_MQuad_ModelTransform_buffer.Get(), 
        0, 
        NULL, 
        &e_conbuf_MQuad_ModelTransform_data, 
        0, 0, 0);


    UINT vb_stride = sizeof(VHG_MQuad_Vertex);
    UINT vb_offset = 0;
    context->IASetVertexBuffers(0, 1, e_vertex_buffer_MQuad.GetAddressOf(), &vb_stride, &vb_offset);
    context->IASetIndexBuffer(e_index_buffer_MQuad.Get(), DXGI_FORMAT_R16_UINT, 0);
    context->IASetInputLayout(e_input_layout_MQuad.Get());
    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);



    context->VSSetShader(e_vertex_shader_MQuad.Get(), nullptr, 0);
    ID3D11Buffer      *mquad_conbuf_array[2];
    mquad_conbuf_array[0] = e_conbuf_MQuad_ViewProjectionTransform_buffer.Get();
    mquad_conbuf_array[1] = e_conbuf_MQuad_ModelTransform_buffer.Get();
    context->VSSetConstantBuffers1(0, 2, mquad_conbuf_array, nullptr, nullptr);






    m_deviceResources->gv_CalcViewports();
    D3D11_VIEWPORT ghv_viewport = m_deviceResources->GetViewport_miniscule();
    context->RSSetViewports(1, &ghv_viewport);





    context->PSSetShader(e_pixel_shader_MQuad.Get(), nullptr, 0);

    context->DrawIndexed(e_ib_indices_card_MQuad, 0, 0);
}
//  Closes VHG_Scene3D1::RenderMQuad(); 









void VHG_Scene3D1::RenderS2sphere(void)
{
    XMMATRIX transposed_world = XMMatrixTranspose(
        XMLoadFloat4x4(&e_conbuf_S2sphere_ModelTransform_data.model_transform)
    );

    XMMATRIX transposed_view = XMMatrixTranspose(
        XMLoadFloat4x4(&e_conbuf_MQuad_ViewProjectionTransform_data.view_transform)
    );

    XMMATRIX transposed_proj = XMMatrixTranspose( 
        XMLoadFloat4x4(&e_conbuf_MQuad_ViewProjectionTransform_data.projection_transform)
    ); 

    auto context = m_deviceResources->GetD3DDeviceContext();

    Create_Rasterizer_State_Wireframe();  // WIREFRAME only!!!
    context->RSSetState(e_rasterizer_state_wireframe.Get());

    context->RSSetViewports(1, &m_deviceResources->GetViewport_miniscule());

    //   
    //   For now, always draw the S2sphere in WIREFRAME mode. 
    //  
    //   To revert, use  e_primitive_sphere->Draw( transposed_world, 
    //   transposed_view, transposed_proj, 
    //   Colors::White, e_texture_srv_S2sphere_sphere.Get() );
    //                  
  
    e_primitive_sphere->Draw(
            transposed_world,
            transposed_view,
            transposed_proj,
            Colors::Blue,
            nullptr,  //  rather than e_texture_srv_2.Get(); 
            true
    );




    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //   
    //     Render INodes: 
    //   
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    context->UpdateSubresource1(e_INodes_MVP_buffer.Get(), 0, NULL, &e_INodes_MVP_data,   0, 0, 0);

    UINT                     INodes_vb_strides[2];
    UINT                     INodes_vb_offsets[2];
    ID3D11Buffer            *INodes_bufferPointers[2];

    INodes_vb_strides[0] = sizeof(VHG_Vertex_PosTex);
    INodes_vb_strides[1] = sizeof(VHG_Instance);

    INodes_vb_offsets[0] = 0;
    INodes_vb_offsets[1] = 0;

    // Set the array of pointers to the vertex and instance buffers
    INodes_bufferPointers[0] = e_HopfSystem->GetINodesVertexBuffer();
    INodes_bufferPointers[1] = e_HopfSystem->GetINodesInstanceBuffer(); 


    // Set both the vertex buffer and the instance buffer in the same call: 
    context->IASetVertexBuffers(0, 2, INodes_bufferPointers, INodes_vb_strides, INodes_vb_offsets);
    // Each index is one 16-bit unsigned integer (short).
    context->IASetIndexBuffer(e_HopfSystem->GetINodesIndexBuffer(), DXGI_FORMAT_R16_UINT, 0);

    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    context->IASetInputLayout(e_input_layout_INodes.Get());

    context->VSSetShader(e_vertex_shader_INodes.Get(), nullptr, 0);
    context->VSSetConstantBuffers1(0, 1, e_INodes_MVP_buffer.GetAddressOf(), nullptr, nullptr);

    context->PSSetShader(e_pixel_shader_INodes.Get(), nullptr, 0);
    context->PSSetShaderResources(0, 1, e_texture_srv_S2sphere_instance.GetAddressOf());
    context->PSSetSamplers(0, 1, e_texture_sampler_state_loft.GetAddressOf());

    Create_Rasterizer_State_Solid();  // SOLID only!!!
    context->RSSetState(e_rasterizer_state_solid.Get());

    context->DrawIndexedInstanced(
        e_HopfSystem->e_INodes_index_buffer_card,        // GetINodesIBIndexCard(),    // m_indexCount,
        e_HopfSystem->e_INodes_instance_card,      // m_instanceCount,
        0,  //   start index location is zero; 
        0,  //   base vertex location is zero; 
        0   //   start instance location is zero; 
    );
}
//  Closes VHG_Scene3D1::RenderS2sphere(); 





void VHG_Scene3D1::Render3DScene_PTF_Loft_2()
{
    static UINT prescale = 0;
    (prescale < 0xFFFF) ? prescale++ : prescale = 0;

    int const max_steps = 256; //  128;   //   Divide the evolution into 64ths; 
    static UINT n_steps = 2;     //   So n_steps will augment until it attains 64 steps, which is 100%; 

    int f1 = 0; 
    int f2 = 0; 
    static int idx_z = 2; 
    if (prescale % 8 == 0)  // GOLD : mod 20 or 14; 
    {
        if (idx_z >= -1 + 2 * max_steps)
        {
            idx_z = 2; 
        }
        else
        {
            idx_z++;
        }

        f1 = idx_z; 
        f2 = 2 * max_steps - idx_z;
        
        n_steps = min(f1, f2); 
    }

    auto context = m_deviceResources->GetD3DDeviceContext();

    UINT entire_fiber_offset = 0;

    std::vector<VHG_Trajectory*>  *all_trajectories = e_HopfSystem->GetAllTrajectories();
    std::vector<VHG_Trajectory*>::iterator iter_all_trajects;

    for ( iter_all_trajects = all_trajectories->begin(); iter_all_trajects != all_trajectories->end(); iter_all_trajects++ )
    {
        std::vector<VHG_Fiber*>               *all_fibers = (*iter_all_trajects)->GetAllFibers();
        std::vector<VHG_Fiber*>::iterator     iter_all_fibers;

        UINT u_arc_density = (*iter_all_trajects)->GetAxonArcDensity();


        for ( iter_all_fibers = all_fibers->begin(); iter_all_fibers != all_fibers->end(); iter_all_fibers++ )
        {
            UINT num_ib_indices = 
                VHG_Scene3D1::e_verts_per_quad *
                VHG_Scene3D1::tubeFacets *
                (*iter_all_trajects)->GetAxonArcDensity();


            UINT draw_count = 0; 

#ifdef GHV_OPTION_ANIMATE_EVOLUTION
            //      Show animated evolution: the fibers grow: 
            UINT partial_count = VHG_Scene3D1::tubeFacets * VHG_Scene3D1::e_verts_per_quad * (-1 + n_steps * u_arc_density / max_steps);
            draw_count = partial_count; 
#else

            //      Run without evolution: 
            draw_count = num_ib_indices;
#endif




#ifdef GHV_OPTION_INDEX_BUFFER

            // undo context->DrawIndexed(draw_count, entire_fiber_offset, 0); 
#else

            context->Draw(draw_count, entire_fiber_offset); 

#endif

            entire_fiber_offset += num_ib_indices;
        }
    }

}
//  Closes VHG_Scene3D1::Render3DScene_PTF_Loft_2(); 










void VHG_Scene3D1::Render3DScene_PTF()  
{ 
    auto context = m_deviceResources->GetD3DDeviceContext();


    context->IASetInputLayout(e_input_layout_loft.Get());

    context->RSSetViewports(1, &m_deviceResources->GetViewport_Majuscule());




    ID3D11Buffer* constantBuffers[] = { e_conbuf_ModelNormal_buffer.Get(), e_conbuf_ViewProjection_buffer.Get() };




    context->VSSetShader(e_vertex_shader_loft.Get(), nullptr, 0);
    context->VSSetConstantBuffers1(
        0,    //  C++ StartSlot = 0; 
        2,
        constantBuffers,
        nullptr,
        nullptr
    );


    context->PSSetShader(e_pixel_shader_loft.Get(), nullptr, 0);
    context->PSSetConstantBuffers1(
        0,    //  C++ StartSlot = 0; 
        2,
        constantBuffers, 
        nullptr,
        nullptr
    );


    context->PSSetShaderResources(
        0,    //  C++ StartSlot = 0 corresponds to HLSL Texture2D Texture_Pure_Fail : register(t0);
        1,
        e_texture_srv_Loft_Pure_Fail.GetAddressOf()
    );
    context->PSSetShaderResources(
        1,    //  C++ StartSlot = 1 corresponds to HLSL Texture2D Texture_Light : register(t1);
        1,
        e_texture_srv_Loft_Ferrero_Rocher.GetAddressOf()
    );

    context->PSSetSamplers(0, 1, e_texture_sampler_state_loft.GetAddressOf());


    Create_Rasterizer_State_Loft();  // re-create in case FILL_MODE has changed; 
    context->RSSetState(e_rasterizer_state_loft.Get());

    //++++++++++++++++++++++++++++++++++++++++++++++++++
    //                  
    //       Render the Lofting Tube[s]: 
    //                  
    //++++++++++++++++++++++++++++++++++++++++++++++++++

    UINT loft_tube_vertex_buffer_stride = sizeof(VHG_Loft_Vertex);
    UINT loft_tube_vertex_buffer_offset = 0;
    context->IASetVertexBuffers(
        0,
        1,
        e_vertex_buffer_loft.GetAddressOf(),
        &loft_tube_vertex_buffer_stride,
        &loft_tube_vertex_buffer_offset
    );

#ifdef GHV_OPTION_INDEX_BUFFER
    context->IASetIndexBuffer(e_index_buffer_loft.Get(), DXGI_FORMAT_R32_UINT, 0);
#endif

    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
 
    Render3DScene_PTF_Loft_2();

    // this->RenderMQuad();   //  let's give this a time-out...

    this->RenderS2sphere(); 
}  
//  Closes VHG_Scene3D1::Render3DScene_PTF();




















void VHG_Scene3D1::Render3DScene()       //  called from main; 
{

    if (!m_loadingComplete)
    {
        return;
    }

    this->debouncer();


    UpdateDynamic_ColoringMode(); // KMI might have altered the fiberColoringMode;


    /*
    m_deviceResources->GetD3DDeviceContext()->UpdateSubresource1( 
        e_conbuf_Loft_ModelViewProjectionTransform_buffer.Get(), 
        0,  NULL, &e_conbuf_Loft_ModelViewProjectionTransform_data,    0,   0,  0 
    );
    */

   
    m_deviceResources->GetD3DDeviceContext()->UpdateSubresource1( 
        e_conbuf_ModelNormal_buffer.Get(), 0,  NULL, &e_conbuf_ModelNormal_data,    0,   0,  0 );


    m_deviceResources->GetD3DDeviceContext()->UpdateSubresource1( 
        e_conbuf_ViewProjection_buffer.Get(), 0,  NULL, &e_conbuf_ViewProjection_data,    0,   0,  0 );


    this->Render3DScene_PTF();
}
//  Closes VHG_Scene3D1::Render3DScene(); //  called from main; 














void VHG_Scene3D1::CreateDeviceDependentResources()
{ 

    e_primitive_sphere = DirectX::GeometricPrimitive::CreateSphere(
        m_deviceResources->GetD3DDeviceContext(),
        1.9f,   //  radius; 
        7,      //  tessellation factor, e.g. 3 for GeoSphere, but 7 for u-v Sphere; 
        false
    );

    // Or, could call  e_primitive = DirectX::GeometricPrimitive::CreateGeoSphere(...); 



    //      
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //                 Load Textures from Image Files          
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //  

    this->Load_Texture_Triax();

  
    //      
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //                Load shaders asynchronously 
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //  


    auto loadVS_Loft_Task = DX::ReadDataAsync(L"gv_Loft_VertexShader.cso");
    auto loadPS_Loft_Task = DX::ReadDataAsync(L"gv_Loft_PixelShader.cso");

    //      
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //                   Create VS Vertex Shader 
    //                   Create Input Layout Object              
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //  

    auto createVS_Loft_Task = loadVS_Loft_Task.then([this](const std::vector<byte>& fileData)
    {
            DX::ThrowIfFailed(
                m_deviceResources->GetD3DDevice()->CreateVertexShader(
                    &fileData[0],
                    fileData.size(),
                    nullptr,
                    e_vertex_shader_loft.GetAddressOf()
                )
            );

            this->Create_Loft_Input_Layout(fileData);
    });

    //      
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //                        Create PS Pixel Shader 
    //                   Create the WVP Constant Buffer               
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
    //  

    auto createPS_Loft_Task = loadPS_Loft_Task.then([this](const std::vector<byte>& fileData)
    {
            DX::ThrowIfFailed(
                m_deviceResources->GetD3DDevice()->CreatePixelShader(
                    &fileData[0],
                    fileData.size(),
                    nullptr,
                    &e_pixel_shader_loft )
            );




            CD3D11_BUFFER_DESC conBufDesc_ModelNormal(
                sizeof(ModelNormalConstantBuffer),
                D3D11_BIND_CONSTANT_BUFFER
            );

            static_assert(
                (sizeof(ModelNormalConstantBuffer) % 16) == 0,
                "Constant Buffer struct must be 16-byte aligned"
                );

            DX::ThrowIfFailed(
                m_deviceResources->GetD3DDevice()->CreateBuffer( 
                    &conBufDesc_ModelNormal, 
                    nullptr, 
                    &e_conbuf_ModelNormal_buffer
                )
            );





            CD3D11_BUFFER_DESC conBufDesc_ViewProjection(
                sizeof(ViewProjectionConstantBuffer),
                D3D11_BIND_CONSTANT_BUFFER
            );

            static_assert(
                (sizeof(ViewProjectionConstantBuffer) % 16) == 0,
                "Constant Buffer struct must be 16-byte aligned"
                );

            DX::ThrowIfFailed(
                m_deviceResources->GetD3DDevice()->CreateBuffer( 
                    &conBufDesc_ViewProjection, 
                    nullptr, 
                    &e_conbuf_ViewProjection_buffer
                )
            );







            CD3D11_BUFFER_DESC conbuf_fiberColoringMode_desc(
                CWS_ALIGNMENT_RoundUpTo16(sizeof(int)),
                D3D11_BIND_CONSTANT_BUFFER,
                D3D11_USAGE_DYNAMIC,
                D3D11_CPU_ACCESS_WRITE
            );

            DX::ThrowIfFailed(
                m_deviceResources->GetD3DDevice()->CreateBuffer( 
                    &conbuf_fiberColoringMode_desc, 
                    nullptr, 
                    &e_conbuf_Loft_fiberColoringMode_buffer 
                )
            );
    });

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //          
    //      MiniSphere MQuad Resources
    //          
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    auto loadVS_MQuad_Task = DX::ReadDataAsync(L"gv_MQuad_VertexShader.cso"); // Load shaders asynchronously.
    auto loadPS_MQuad_Task = DX::ReadDataAsync(L"gv_MQuad_PixelShader.cso"); // Load shaders asynchronously.

    auto createVS_MQuad_Task = loadVS_MQuad_Task.then([this](const std::vector<byte>& fileData) {
        DX::ThrowIfFailed(m_deviceResources->GetD3DDevice()->CreateVertexShader(
            &fileData[0], fileData.size(), nullptr, &e_vertex_shader_MQuad)
        );

        {
            static const D3D11_INPUT_ELEMENT_DESC vertexDesc_MQuad[] = 
            { 
                { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0 }, // POSITION0;
                { "COLOR",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }, // COLOR0;
            };

            DX::ThrowIfFailed(m_deviceResources->GetD3DDevice()->CreateInputLayout(
                vertexDesc_MQuad, ARRAYSIZE(vertexDesc_MQuad), &fileData[0], fileData.size(), &e_input_layout_MQuad)
            );
        }
    });


    auto createPS_MQuad_Task = loadPS_MQuad_Task.then([this](const std::vector<byte>& fileData)
    {
        DX::ThrowIfFailed(m_deviceResources->GetD3DDevice()->CreatePixelShader(
            &fileData[0], fileData.size(), nullptr, &e_pixel_shader_MQuad));

        CD3D11_BUFFER_DESC conbuf_desc_ViewProj(sizeof(VHG_conbuf_ViewProjectionTransform_struct), D3D11_BIND_CONSTANT_BUFFER);

        DX::ThrowIfFailed(
            m_deviceResources->GetD3DDevice()->CreateBuffer(
                &conbuf_desc_ViewProj,
                nullptr,
                &e_conbuf_MQuad_ViewProjectionTransform_buffer
            )
        );

        CD3D11_BUFFER_DESC conbuf_desc_ModelTransform(sizeof(VHG_conbuf_ModelTransform_struct), D3D11_BIND_CONSTANT_BUFFER);

        DX::ThrowIfFailed(
            m_deviceResources->GetD3DDevice()->CreateBuffer(
                &conbuf_desc_ModelTransform,
                nullptr,
                &e_conbuf_MQuad_ModelTransform_buffer
            )
        );
    });


    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //          
    //      MiniSphere INode Resources
    //          
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    auto loadVS_INode_Task = DX::ReadDataAsync(L"gv_INode_VertexShader.cso");
    auto loadPS_INode_Task = DX::ReadDataAsync(L"gv_INode_PixelShader.cso");


    auto createVS_INode_Task = loadVS_INode_Task.then([this](const std::vector<byte>& fileData) {
        DX::ThrowIfFailed(
            m_deviceResources->GetD3DDevice()->CreateVertexShader(
                &fileData[0],
                fileData.size(),
                nullptr,
                &e_vertex_shader_INodes
            )
        );

        static const D3D11_INPUT_ELEMENT_DESC vertexDesc[] =
        {
            { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA,   0 },
            { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 12, D3D11_INPUT_PER_VERTEX_DATA,   0 },
            { "TEXCOORD", 1, DXGI_FORMAT_R32G32B32_FLOAT, 1,  0, D3D11_INPUT_PER_INSTANCE_DATA, 1 }  // TODO: ??? why no byte offset ???
        };


        DX::ThrowIfFailed(
            m_deviceResources->GetD3DDevice()->CreateInputLayout(
                vertexDesc,
                ARRAYSIZE(vertexDesc),
                &fileData[0],
                fileData.size(),
                &e_input_layout_INodes
            )
        );
    });


    auto createPS_INode_Task = loadPS_INode_Task.then([this](const std::vector<byte>& fileData) {
        DX::ThrowIfFailed(
            m_deviceResources->GetD3DDevice()->CreatePixelShader(
                &fileData[0],
                fileData.size(),
                nullptr,
                &e_pixel_shader_INodes
            )
        );


        CD3D11_BUFFER_DESC INodes_constantBufferDesc(
            sizeof(VHG_conbuf_MVP_struct), 
            D3D11_BIND_CONSTANT_BUFFER
        );

        DX::ThrowIfFailed(
            m_deviceResources->GetD3DDevice()->CreateBuffer(
                &INodes_constantBufferDesc,
                nullptr,
                &e_INodes_MVP_buffer
            )
        );
    });







    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    auto createCubeTask = ( 
        createVS_Loft_Task && 
        createPS_Loft_Task &&
        createVS_MQuad_Task &&
        createPS_MQuad_Task &&
        createVS_INode_Task &&
        createPS_INode_Task
    ).then([this]()
    {
        Create_Sampler_State_Loft(); 
        
        Create_Rasterizer_State_Loft();

        gv_load_hopf_system(); 
    }
    );






    createCubeTask.then([this]()
    {
            this->m_loadingComplete = true;
    });

}  
//  Closes VHG_Scene3D1::CreateDeviceDependentResources();










void VHG_Scene3D1::ReleaseDeviceDependentResources()
{
    m_loadingComplete = false; 

    e_conbuf_ModelNormal_buffer.Reset(); 
    e_conbuf_ViewProjection_buffer.Reset(); 

}
//  Closes VHG_Scene3D1::ReleaseDeviceDependentResources(); 




//                 ...file ends... 

